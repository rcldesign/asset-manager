Based on my research, I found that openid-client does NOT provide a public `verifyIdToken` method. The library marks `validateJWT` as private (GitHub issue #393). However, proper verification requires:

1. **Signature verification using JWKS** - The library handles this during the authorization code exchange  
2. **Standard claims validation** - Custom implementation needed for nonce, audience, issuer validation
3. **Current implementation is indeed critically insecure** - Only decodes without signature verification

## My Final Critical Evaluation

**Technical Merit Assessment:**

✅ **High Value - Decoupled Async Initializer Pattern:**
- Separates concerns effectively 
- Makes testing dramatically simpler
- Addresses core brittleness while minimizing disruption
- Clean architectural pattern used in enterprise applications

❌ **Limited Value - Static Factory Pattern alone:**
- Breaking change to singleton pattern would require extensive codebase changes
- The `export const oidcService` pattern is likely used across multiple files
- Risk of introducing bugs in unrelated parts of the application

✅ **Critical - Security Fix Priority:**
- The verifyIdToken vulnerability is indeed critical and must be addressed first
- However, proper fix is complex since openid-client doesn't expose verification methods
- Need to implement custom JWT verification with JWKS or rely on the token exchange flow

## Architecture & Constraints Analysis

**Existing Patterns Impact:**
- The codebase follows service singleton patterns consistently
- Breaking this would require changes to auth middleware, route handlers, and other consumers
- Performance: Current lazy initialization is optimal for apps that may not use OIDC

**Hidden Complexity in Recommendations:**

1. **Decoupled Pattern Complexity**: While architecturally cleaner, introduces new failure modes:
   - Timing issues if `getOidcService()` called before `initializeOidc()`
   - Need for proper error handling in initialization sequence
   - Application startup orchestration becomes more complex

2. **Testing Isolation**: The proposed solution actually creates better test isolation than the hybrid approach

## Risk Assessment

**Deployment Risks:**
- The architectural changes, while beneficial, touch a critical authentication component
- Need careful rollout strategy and comprehensive integration testing
- Could break existing authentication flows if not implemented carefully

**Security Risks:**
- Current verifyIdToken is completely broken and dangerous
- Must be fixed before any refactoring

## My Synthesized Final Recommendation

I propose a **three-phase incremental approach** that balances immediate security needs with longer-term architectural improvements:

### Phase 1 (Immediate - Security Fix)
- Fix verifyIdToken security vulnerability by implementing proper JWT verification 
- Use the industry-standard approach: fetch JWKS, verify signature, validate claims
- Keep current architecture intact for this critical fix

### Phase 2 (Short-term - Test Improvements)  
- Implement the initialization promise tracking approach for tests only
- Add `waitForInitialization()` method that tests can await
- This eliminates setTimeout without breaking production code

### Phase 3 (Medium-term - Architecture)
- Implement the decoupled async initializer pattern 
- Migrate consumers gradually using feature flags or staged rollout
- Comprehensive integration testing before full migration

This approach prioritizes security, minimizes risk, and provides incremental value. Should I proceed with Phase 1 - the immediate security fix?